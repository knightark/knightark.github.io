
 <!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="UTF-8">
  
    <title>C#动态创建和动态使用程序集、类、方法、字段等(一) | 个人博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="knightark">
    

    
    <meta name="description" content="有时候在整个项目架构里也需要动态创建程序集的需求，那如何创建程序集，其实主要使用的是反射的方式，然后通过IL编译器编译后形成DLL。">
<meta property="og:type" content="article">
<meta property="og:title" content="C#动态创建和动态使用程序集、类、方法、字段等(一)">
<meta property="og:url" content="https://knightark.github.io/2021/01/27/C#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%BF%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%9B%86%E3%80%81%E7%B1%BB%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%AD%97%E6%AE%B5%E7%AD%89(%E4%B8%80)/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="有时候在整个项目架构里也需要动态创建程序集的需求，那如何创建程序集，其实主要使用的是反射的方式，然后通过IL编译器编译后形成DLL。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.cnblogs.com/skins/custom/images/logo.gif">
<meta property="article:published_time" content="2021-01-27T07:13:33.000Z">
<meta property="article:modified_time" content="2021-06-08T03:55:53.825Z">
<meta property="article:author" content="knightark">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="Assembly">
<meta property="article:tag" content="程序集">
<meta property="article:tag" content="动态创建程序集">
<meta property="article:tag" content="组态编程">
<meta property="article:tag" content="动态编译">
<meta property="article:tag" content="反射">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.cnblogs.com/skins/custom/images/logo.gif">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/%02.css">
<link rel="stylesheet" href="/.css">

<meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="个人博客" title="个人博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="个人博客">个人博客</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:knightark.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2021/01/27/C#动态创建和动态使用程序集、类、方法、字段等(一)/" title="C#动态创建和动态使用程序集、类、方法、字段等(一)" itemprop="url">C#动态创建和动态使用程序集、类、方法、字段等(一)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="knightark" target="_blank" itemprop="author">knightark</a>
		
  <p class="article-time">
    <time datetime="2021-01-27T07:13:33.000Z" itemprop="datePublished"> Published 2021-01-27</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%BF%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%9B%86%E3%80%81%E7%B1%BB%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%AD%97%E6%AE%B5%E7%AD%89-%E4%B8%80"><span class="toc-number">1.</span> <span class="toc-text">C#动态创建和动态使用程序集、类、方法、字段等(一)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">动态创建代码</span></a></li></ol>
		
		</div>
		
		<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/longgel/"><img src="https://www.cnblogs.com/skins/custom/images/logo.gif" alt="返回主页"></a>    </p>
<h1 id="C-动态创建和动态使用程序集、类、方法、字段等-一"><a href="#C-动态创建和动态使用程序集、类、方法、字段等-一" class="headerlink" title="C#动态创建和动态使用程序集、类、方法、字段等(一)"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/longgel/archive/2010/05/14/1735590.html">C#动态创建和动态使用程序集、类、方法、字段等(一)</a></h1><p>有时候在整个项目架构里也需要动态创建程序集的需求，那如何创建程序集呢，请跟我来学习一下吧。</p>
<p>　　首先需要知道动态创建这些类型是使用的一些什么技术呢？其实只要相关动态加载程序集呀，类呀，都是使用反射，那么动态创建也一样使用的是反射，是属于反射的技术！也就是将对象或者数据映射成一个对象或者程序集保存起来而已。</p>
<p>　　首先我们需要了解每个动态类型在.net中都是用什么类型来表示的。</p>
<p>程序集：System.Reflection.Emit.AssemblyBuilder(定义并表示动态程序集)</p>
<p>构造函数：System.Reflection.Emit.ConstructorBuilder(定义并表示动态类的构造函数)</p>
<p>自定义属性：System.Reflection.Emit.CustomAttributeBuilder(帮助生成自定义属性 使用构造函数传递的参数来生成类的属性)</p>
<p>枚举：System.Reflection.Emit.EnumBuilder(说明并表示枚举类型)</p>
<p>事件：System.Reflection.Emit.EventBuilder(定义类的事件)</p>
<p>字段：System.Reflection.Emit.FieldBuilder(定义并表示字段。无法继承此类)</p>
<p>局部变量：System.Reflection.Emit.LocalBuilder(表示方法或构造函数内的局部变量)</p>
<p>方法：System.Reflection.Emit.MethodBuilder(定义并表示动态类的方法（或构造函数）)</p>
<p>模块：System.Reflection.Emit.ModuleBuilder(定义和表示动态程序集中的模块)</p>
<p>参数：System.Reflection.Emit.ParameterBuilder(创建或关联参数信息 如：方法参数，事件参数等)</p>
<p>属性：System.Reflection.Emit.PropertyBuilder(定义类型的属性 (Property))</p>
<p>类：System.Reflection.Emit.TypeBuilder(在运行时定义并创建类的新实例)</p>
<p>　　我们有了这些类型，基本上就可以动态创建我们的任何需要使用的类型，当然很多可以动态创建的类型我不可能都介绍完，如果在项目中有需要可以去查阅MSDN，里面都有DEMO的，主要的问题就是要理解每一种类型的定义，比如：程序集加载是靠AppDomain，程序集里包含多个模块，模块里可以声明类，类里可以创建方法、属性、字段。方法需要在类中才可以创建的，局部变量是声明在方法体内等等规则。看MSDN就非常容易弄懂了。</p>
<p>1.如何动态创建它们了</p>
<p>AppDomain：应用程序域（由 <strong>AppDomain</strong> 对象表示）为执行托管代码提供隔离、卸载和安全边界。AppDomain同时可以载入多个程序集，共同来实现功能。</p>
<p>程序集：简单来说就是一个以公共语言运行库（CLR）为宿主的、版本化的、自描述的二进制文件。（说明：定义来自C#与.NET3.5高级程序设计(第四版)）</p>
<p>模块：类似于以前的单元，用于分割不同的类和类型，以及资源(resource, 资源记录就是字符串，图象以及其它数据，他们只在需要的时候才会被调入内存)。类型的Meta信息也是模块的一部分。多个模块组建成一个程序集。</p>
<p>所谓动态就是在程序运行时，动态的创建和使用。</p>
<p>直接看代码吧，其实超级简单。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态创建程序集</span></span><br><span class="line">​AssemblyName DemoName = <span class="keyword">new</span> AssemblyName(<span class="string">&quot;DynamicAssembly&quot;</span>);</span><br><span class="line">​AssemblyBuilder dynamicAssembly = AppDomain.CurrentDomain.DefineDynamicAssembly(DemoName, AssemblyBuilderAccess.RunAndSave);</span><br><span class="line">​<span class="comment">//动态创建模块</span></span><br><span class="line">​ModuleBuilder mb = dynamicAssembly.DefineDynamicModule(DemoName.Name, DemoName.Name + <span class="string">&quot;.dll&quot;</span>);</span><br><span class="line">​<span class="comment">//动态创建类MyClass</span></span><br><span class="line">​TypeBuilder tb = mb.DefineType(<span class="string">&quot;MyClass&quot;</span>, TypeAttributes.Public);</span><br><span class="line">​<span class="comment">//动态创建字段</span></span><br><span class="line">​FieldBuilder fb = tb.DefineField(<span class="string">&quot;&quot;</span>, <span class="keyword">typeof</span>(System.String), FieldAttributes.Private); </span><br><span class="line">​<span class="comment">//动态创建构造函数</span></span><br><span class="line">​Type[] clorType = <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(System.String) &#125;;</span><br><span class="line">​ConstructorBuilder cb1 = tb.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, clorType);</span><br><span class="line">​<span class="comment">//生成指令</span></span><br><span class="line">​ILGenerator ilg = cb1.GetILGenerator();<span class="comment">//生成 Microsoft 中间语言 (MSIL) 指令</span></span><br><span class="line">​ilg.Emit(OpCodes.Ldarg_0);</span><br><span class="line">​ilg.Emit(OpCodes.Call, <span class="keyword">typeof</span>(<span class="built_in">object</span>).GetConstructor(Type.EmptyTypes));</span><br><span class="line">​ilg.Emit(OpCodes.Ldarg_0);</span><br><span class="line">​ilg.Emit(OpCodes.Ldarg_1);</span><br><span class="line">​ilg.Emit(OpCodes.Stfld, fb);</span><br><span class="line">​ilg.Emit(OpCodes.Ret);</span><br><span class="line">​<span class="comment">//动态创建属性</span></span><br><span class="line">​PropertyBuilder pb = tb.DefineProperty(<span class="string">&quot;MyProperty&quot;</span>, PropertyAttributes.HasDefault, <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="literal">null</span>);</span><br><span class="line">​<span class="comment">//动态创建方法</span></span><br><span class="line">​MethodAttributes getSetAttr = MethodAttributes.Public | MethodAttributes.SpecialName;</span><br><span class="line">​MethodBuilder myMethod = tb.DefineMethod(<span class="string">&quot;get_Property&quot;</span>, getSetAttr, <span class="keyword">typeof</span>(<span class="built_in">string</span>), Type.EmptyTypes);</span><br><span class="line">​<span class="comment">//生成指令</span></span><br><span class="line">​ILGenerator numberGetIL = myMethod.GetILGenerator();</span><br><span class="line">​numberGetIL.Emit(OpCodes.Ldarg_0);</span><br><span class="line">​numberGetIL.Emit(OpCodes.Ldfld, fb);</span><br><span class="line">​numberGetIL.Emit(OpCodes.Ret);</span><br><span class="line">​<span class="comment">//保存动态创建的程序集</span></span><br><span class="line">​dynamicAssembly.Save(DemoName.Name + <span class="string">&quot;.dll&quot;</span>);</span><br></pre></td></tr></table></figure>





<p>上一节讲了如何动态的创建，这一节就要讲创建了我们需要如何使用了，这当然也是非常重要的， 是吧。创建了动态类型但是又不使用，那创建它有什么用了。呵呵，今天我们就来一起学习动态使用动态创建的类型。</p>
<p>当然我们跟上一章一样要对这些动态类型的使用类型进行一些了解。</p>
<p>类：使用System.Type(任何时候都是反射出类型进行使用，难道不是吗？)</p>
<p>构造函数：System.Reflection.ConstructorInfo(发现类构造函数的属性并提供对构造函数元数据的访问权)</p>
<p>事件：System.Reflection.EventInfo(发现事件的属性并提供对事件元数据的访问权)</p>
<p>字段：System.Reflection.FieldInfo(发现字段属性并提供对字段元数据的访问权)</p>
<p>方法：System.Reflection.MemberInfo(获取有关成员属性的信息并提供对成员元数据的访问)</p>
<p>成员：System.Reflection.MemberInfo(获取有关成员属性的信息并提供对成员元数据的访问)</p>
<p>参数：System.Reflection.ParameterInfo(发现参数属性并提供对参数元数据的访问)</p>
<p>属性：System.Reflection.PropertyInfo (发现属性 (Property) 的属性 (Attribute) 并提供对属性 (Property) 元数据的访问)</p>
<p>同样这是一种延伸阅读，只是先对这些进行了解，如果不知道的话，可能对动态的使用类型就无法下手了。</p>
<p>今天我做了一个Demo，先上Demo吧，然后在来解释程序是如何执行的。</p>
<p>/动态创建的动态类型</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Type <span class="title">DynamicCreateType</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//动态创建程序集</span></span><br><span class="line">    AssemblyName DemoName = <span class="keyword">new</span> AssemblyName(<span class="string">&quot;DynamicAssembly&quot;</span>);</span><br><span class="line">    AssemblyBuilder dynamicAssembly = AppDomain.CurrentDomain.DefineDynamicAssembly(DemoName, AssemblyBuilderAccess.RunAndSave);</span><br><span class="line">    <span class="comment">//动态创建模块</span></span><br><span class="line">    ModuleBuilder mb = dynamicAssembly.DefineDynamicModule(DemoName.Name, DemoName.Name + <span class="string">&quot;.dll&quot;</span>);</span><br><span class="line">    <span class="comment">//动态创建类MyClass</span></span><br><span class="line">    TypeBuilder tb = mb.DefineType(<span class="string">&quot;MyClass&quot;</span>, TypeAttributes.Public);</span><br><span class="line">    <span class="comment">//动态创建字段</span></span><br><span class="line">    FieldBuilder fb = tb.DefineField(<span class="string">&quot;myField&quot;</span>, <span class="keyword">typeof</span>(System.String), FieldAttributes.Private);  </span><br><span class="line">    <span class="comment">//动态创建构造函数</span></span><br><span class="line">    Type[] clorType = <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(System.String) &#125;;</span><br><span class="line">    ConstructorBuilder cb1 = tb.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, clorType);</span><br><span class="line">    <span class="comment">//生成指令</span></span><br><span class="line">    ILGenerator ilg = cb1.GetILGenerator();<span class="comment">//生成 Microsoft 中间语言 (MSIL) 指令</span></span><br><span class="line">    ilg.Emit(OpCodes.Ldarg_0);</span><br><span class="line">    ilg.Emit(OpCodes.Call, <span class="keyword">typeof</span>(<span class="built_in">object</span>).GetConstructor(Type.EmptyTypes));</span><br><span class="line">    ilg.Emit(OpCodes.Ldarg_0);</span><br><span class="line">    ilg.Emit(OpCodes.Ldarg_1);</span><br><span class="line">    ilg.Emit(OpCodes.Stfld, fb);</span><br><span class="line">    ilg.Emit(OpCodes.Ret);</span><br><span class="line">    <span class="comment">//动态创建属性</span></span><br><span class="line">    PropertyBuilder pb = tb.DefineProperty(<span class="string">&quot;MyProperty&quot;</span>, PropertyAttributes.HasDefault, <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//动态创建方法</span></span><br><span class="line">    MethodAttributes getSetAttr = MethodAttributes.Public | MethodAttributes.SpecialName;</span><br><span class="line">    MethodBuilder myMethod = tb.DefineMethod(<span class="string">&quot;get_Field&quot;</span>, getSetAttr, <span class="keyword">typeof</span>(<span class="built_in">string</span>), Type.EmptyTypes);</span><br><span class="line">    <span class="comment">//生成指令</span></span><br><span class="line">    ILGenerator numberGetIL = myMethod.GetILGenerator();</span><br><span class="line">    numberGetIL.Emit(OpCodes.Ldarg_0);</span><br><span class="line">    numberGetIL.Emit(OpCodes.Ldfld, fb);</span><br><span class="line">    numberGetIL.Emit(OpCodes.Ret);</span><br><span class="line">    <span class="comment">//使用动态类创建类型</span></span><br><span class="line">    Type classType = tb.CreateType();</span><br><span class="line">    <span class="comment">//保存动态创建的程序集 (程序集将保存在程序目录下调试时就在Debug下)</span></span><br><span class="line">    dynamicAssembly.Save(DemoName.Name + <span class="string">&quot;.dll&quot;</span>);</span><br><span class="line">    <span class="comment">//创建类</span></span><br><span class="line">    <span class="keyword">return</span> classType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>执行的主要方法</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//动态创建的类类型</span></span><br><span class="line">    Type classType = DynamicCreateType();</span><br><span class="line">    <span class="comment">//调用有参数的构造函数</span></span><br><span class="line">    Type[] ciParamsTypes = <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">string</span>) &#125;;</span><br><span class="line">    <span class="built_in">object</span>[] ciParamsValues = <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="string">&quot;Hello World&quot;</span> &#125;;</span><br><span class="line">    ConstructorInfo ci = classType.GetConstructor(ciParamsTypes);</span><br><span class="line">    <span class="built_in">object</span> Vector = ci.Invoke(ciParamsValues);</span><br><span class="line">    <span class="comment">//调用方法</span></span><br><span class="line">    <span class="built_in">object</span>[] methedParams=<span class="keyword">new</span> <span class="built_in">object</span>[]&#123;&#125;;</span><br><span class="line">    Console.WriteLine(classType.InvokeMember(<span class="string">&quot;get_Property&quot;</span>, BindingFlags.InvokeMethod, <span class="literal">null</span>, Vector, methedParams));</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这个程序首先调用DynamicCreateType()方法创建动态类型，这跟第一章里帖出来的如何创建的代码几乎是一样的，另外保存了动态创建的程序集，我创建了一个类，类里创建了有一个字段、有一个参数的构造函数、一个属性、有一个参数的构造函数和一个方法。用有参数的构造函数来初始化字段myField，然后调用get_Field方法返回myField字段的值。控制台程序显示“Hello World!!!”</p>
<p>后面还会继续介绍动态创建和动态使用类，如何创建复杂的方法，特别是中间语言(MSIL)的生成。</p>
<p>动态创建方法和使用msil指令动态写入方法一(了解ILGenerator)</p>
<pre><code> 之前讲过关于如何动态创建和使用程序集、类、方法、字段、属性等两篇文章，第一篇主要讲了介绍动态创建类型的一些基本知识和如何创建程序集、类等，第二篇主要介绍的是如何使用动态创建的程序集，调用动态创建类的方法等的一个完整DEMO。今天讲的其实也是关于在动态创建类型里，如何动态的创建一个较复杂的方法，当然今天这一篇主要着重以介绍如何ILGenerator和一些概念，下一篇就来介绍MSIL指令集。

 何为MSIL(中间语言)，我想大家都可能认识它，但是完全了解它和使用它的我估计大家都要跟我一样还得继续学习MSIL。那我也就不介绍了，其实今天我要介绍的是通过ILGenerator 发出MSIL指令到MethedBuilder(方法)或者是ConstructorBuilder(构造函数)来生成方法和构造函数，其实大家可能会有一个疑问，为什么非得一定要使用MSIL来完成方法和构造函数的方法体了？

 这个原因其实主要是因为我们的程序是动态创建一个程序集，我们的方法不是生成一段代码然后动态调用编译器来完成生成一个程序集，而我们是从一开始就是使用创建程序集并向程序集里添加相应的类型，所以我们的这个程序集就必须需要实时编译的，我们需要将指令发送到（JIT编译器）的流上，没有经过如C#编译器或者是VB编译器来将代码转化为MSIL指讼。所以我们就需要动态的写入的是MSIL指令，而不是C#或者是VB.NET代码。
</code></pre>
<p>当然要知道如何向方法里输入MSIL指令呢？那我们就得要熟悉一些相关知识了。</p>
<p>System.Reflection.Emit.ILGenerator类提供可用于发出 Microsoft 中间语言 (MSIL) 的方法。ConstructorBuilder.GetILGenerator 方法为构造函数返回 ILGenerator。MethodBuilder.GetILGenerator 方法为方法返回 ILGenerator。</p>
<p>那么ILGenerator的主要提供那些功能呢？</p>
<p>1.使用 ILGenerator.Emit 方法的不同形式发出各种指令。这些指令将根据指令的类型带不同类别的操作数。（该方法将会是使用的非常多的方法）</p>
<p>2.ILGenerator.DefineLabel方法声明标签和ILGenerator.MarkLabel方法标记标签在MSIL流的当前位置。</p>
<p>3.ILGenerator.ThrowException方法用来发出引发异常的指令。</p>
<p>4.定义异常模块</p>
<p>(1)ILGenerator.BeginExceptionBlock 开始异常块。</p>
<p>(2)ILGenerator.BeginExceptFilterBlock 开始筛选的异常处理程序。</p>
<p>(3)ILGenerator.BeginCatchBlock 开始类型化异常处理程序。</p>
<p>(4)ILGenerator.BeginFinallyBlock 开始 finally 处理程序。</p>
<p>(5)ILGenerator.BeginFaultBlock 开始错误处理程序。</p>
<p>(6)ILGenerator.EndExceptionBlock 结束异常块。</p>
<p>5.定义词法范围</p>
<p>(1)ILGenerator.BeginScope 开始词法范围</p>
<p>(2)ILGenerator.EndScope 结束词法范围</p>
<p>6.ILGenerator.DeclareLocal定义局部变量</p>
<p>看下面代码列出ILGenerator常用方法的使用及演示代码，看一下就能理解了<br>复制代码<br>            //通过adderBldr方法获取ILGenerator对象<br>            ILGenerator ilgen = adderBldr.GetILGenerator();<br>            Type overflow = typeof(OverflowException);<br>            ConstructorInfo exCtorInfo = overflow.GetConstructor(<br>                              new Type[] { typeof(string) });<br>            //定义局部变量<br>            LocalBuilder tmp1 = ilgen.DeclareLocal(typeof(int));<br>            LocalBuilder tmp2 = ilgen.DeclareLocal(overflow);<br>            //定义标签<br>            Label failed = ilgen.DefineLabel();<br>            Label endOfMthd = ilgen.DefineLabel();<br>            //标记异常块开始(try)<br>            Label exBlock = ilgen.BeginExceptionBlock();<br>            //发出MSIL指令<br>            ilgen.Emit(OpCodes.Ldarg_0);<br>            //在当前MSIL流位置进行标记<br>            ilgen.MarkLabel(failed);<br>            //抛出异常<br>            ilgen.ThrowException(overflow);<br>            //声明异常块开始(Catch)<br>            ilgen.BeginCatchBlock(overflow);<br>            ilgen.Emit(OpCodes.Stloc_S, tmp2);<br>            ilgen.Emit(OpCodes.Ldstr, “Caught {0}”);<br>            ilgen.Emit(OpCodes.Ldloc_S, tmp2);<br>            ilgen.Emit(OpCodes.Ldc_I4_M1);<br>            ilgen.Emit(OpCodes.Stloc_S, tmp1);<br>            //声明异常块结束<br>            ilgen.EndExceptionBlock();<br>复制代码</p>
<p> 今天提到的只是在动态创建方法时使用发出指令的一个帮助类，下一章我们就需要了解MSIL指令和如何输出MSIL指令的。</p>
<h1 id="动态创建代码"><a href="#动态创建代码" class="headerlink" title="动态创建代码"></a>动态创建代码</h1><p>C# 在运行时动态的创建类型是通过动态生成C#源代码，然后通过编译器编译成程序集的方式实现动态创建类型的。</p>
<p> 主要功能代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Assembly <span class="title">NewAssembly</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//创建编译器实例。 </span></span><br><span class="line"> provider = <span class="keyword">new</span> CSharpCodeProvider();</span><br><span class="line"> <span class="comment">//设置编译参数。 </span></span><br><span class="line"> cp = <span class="keyword">new</span> CompilerParameters();</span><br><span class="line"> cp.GenerateExecutable = <span class="literal">false</span>;</span><br><span class="line"> cp.GenerateInMemory = <span class="literal">true</span>;</span><br><span class="line"> <span class="comment">// Generate an executable instead of</span></span><br><span class="line"> <span class="comment">// a class library.</span></span><br><span class="line"> <span class="comment">//cp.GenerateExecutable = true;</span></span><br><span class="line"> <span class="comment">// Set the assembly file name to generate.</span></span><br><span class="line"> cp.OutputAssembly = <span class="string">&quot;c:\\1.dll&quot;</span>;</span><br><span class="line"> <span class="comment">// Generate debug information.</span></span><br><span class="line"> cp.IncludeDebugInformation = <span class="literal">true</span>;</span><br><span class="line"> <span class="comment">// Save the assembly as a physical file.</span></span><br><span class="line"> cp.GenerateInMemory = <span class="literal">false</span>;</span><br><span class="line"> <span class="comment">// Set the level at which the compiler</span></span><br><span class="line"> <span class="comment">// should start displaying warnings.</span></span><br><span class="line"> cp.WarningLevel = <span class="number">3</span>;</span><br><span class="line"> <span class="comment">// Set whether to treat all warnings as errors.</span></span><br><span class="line"> cp.TreatWarningsAsErrors = <span class="literal">false</span>;</span><br><span class="line"> <span class="comment">// Set compiler argument to optimize output.</span></span><br><span class="line"> cp.CompilerOptions = <span class="string">&quot;/optimize&quot;</span>;</span><br><span class="line"> cp.ReferencedAssemblies.Add(<span class="string">&quot;System.dll&quot;</span>);</span><br><span class="line"> <span class="comment">//cp.ReferencedAssemblies.Add(&quot;System.Core.dll&quot;);</span></span><br><span class="line"> cp.ReferencedAssemblies.Add(<span class="string">&quot;System.Data.dll&quot;</span>);</span><br><span class="line"> <span class="comment">//cp.ReferencedAssemblies.Add(&quot;System.Data.DataSetExtensions.dll&quot;);</span></span><br><span class="line"> cp.ReferencedAssemblies.Add(<span class="string">&quot;System.Deployment.dll&quot;</span>);</span><br><span class="line"> cp.ReferencedAssemblies.Add(<span class="string">&quot;System.Design.dll&quot;</span>);</span><br><span class="line"> cp.ReferencedAssemblies.Add(<span class="string">&quot;System.Drawing.dll&quot;</span>);</span><br><span class="line"> cp.ReferencedAssemblies.Add(<span class="string">&quot;System.Windows.Forms.dll&quot;</span>);</span><br><span class="line"> <span class="comment">//创建动态代码。 </span></span><br><span class="line"> StringBuilder classSource = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"> classSource.Append(<span class="string">&quot;using System;using System.Windows.Forms;\npublic class DynamicClass: UserControl \n&quot;</span>);</span><br><span class="line"> classSource.Append(<span class="string">&quot;&#123;\n&quot;</span>);</span><br><span class="line"> classSource.Append(<span class="string">&quot;public DynamicClass()\n&#123;\nInitializeComponent();\nConsole.WriteLine(\&quot;hello\&quot;);&#125;\n&quot;</span>);</span><br><span class="line"> classSource.Append( <span class="string">&quot;private System.ComponentModel.IContainer  components = null;\nprotected override void Dispose(bool  disposing)\n&#123;\n&quot;</span>);</span><br><span class="line"> classSource.Append( <span class="string">&quot;if (disposing &amp;&amp; (components != null))&#123;components.Dispose();&#125;base.Dispose(disposing);\n&#125;\n&quot;</span>);</span><br><span class="line"> classSource.Append( <span class="string">&quot;private void  InitializeComponent()&#123;\nthis.SuspendLayout();this.AutoScaleDimensions =  new System.Drawing.SizeF(6F, 12F);&quot;</span>);</span><br><span class="line"> classSource.Append( <span class="string">&quot;this.AutoScaleMode =  System.Windows.Forms.AutoScaleMode.Font;this.Name =  \&quot;DynamicClass\&quot;;this.Size = new System.Drawing.Size(112,  74);this.ResumeLayout(false);\n&#125;&quot;</span>);</span><br><span class="line"> <span class="comment">//创建属性。 </span></span><br><span class="line"> <span class="comment">/*************************在这里改成需要的属性******************************/</span></span><br><span class="line"> classSource.Append(propertyString(<span class="string">&quot;aaa&quot;</span>));</span><br><span class="line"> classSource.Append(propertyString(<span class="string">&quot;bbb&quot;</span>));</span><br><span class="line"> classSource.Append(propertyString(<span class="string">&quot;ccc&quot;</span>));</span><br><span class="line"> classSource.Append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line"> System.Diagnostics.Debug.WriteLine(classSource.ToString());</span><br><span class="line"> <span class="comment">//编译代码。 </span></span><br><span class="line"> CompilerResults result = provider.CompileAssemblyFromSource(cp, classSource.ToString());</span><br><span class="line"> <span class="keyword">if</span> (result.Errors.Count &gt; <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">for</span>( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; result.Errors.Count; i ++)</span><br><span class="line">  Console.WriteLine(result.Errors[ i]);</span><br><span class="line"> Console.WriteLine(<span class="string">&quot;error&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//获取编译后的程序集。 </span></span><br><span class="line"> Assembly assembly = result.CompiledAssembly;</span><br><span class="line"> <span class="keyword">return</span> assembly;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">propertyString</span>(<span class="params"><span class="built_in">string</span> propertyName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> StringBuilder sbProperty = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"> sbProperty.Append(<span class="string">&quot; private int _&quot;</span> + propertyName + <span class="string">&quot; = 0;\n&quot;</span>);</span><br><span class="line"> sbProperty.Append(<span class="string">&quot; public int &quot;</span> + <span class="string">&quot;&quot;</span> + propertyName + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> sbProperty.Append(<span class="string">&quot; &#123;\n&quot;</span>);</span><br><span class="line"> sbProperty.Append(<span class="string">&quot; get&#123; return _&quot;</span> + propertyName + <span class="string">&quot;;&#125; \n&quot;</span>);</span><br><span class="line"> sbProperty.Append(<span class="string">&quot; set&#123; _&quot;</span> + propertyName + <span class="string">&quot; = value; &#125;\n&quot;</span>);</span><br><span class="line"> sbProperty.Append(<span class="string">&quot; &#125;&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> sbProperty.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C/">C#</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C#</a><a href="/tags/Assembly/">Assembly</a><a href="/tags/程序集/">程序集</a><a href="/tags/动态创建程序集/">动态创建程序集</a><a href="/tags/组态编程/">组态编程</a><a href="/tags/动态编译/">动态编译</a><a href="/tags/反射/">反射</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://knightark.github.io/2021/01/27/C#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%BF%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%9B%86%E3%80%81%E7%B1%BB%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%AD%97%E6%AE%B5%E7%AD%89(%E4%B8%80)/" data-title="C#动态创建和动态使用程序集、类、方法、字段等(一) | 个人博客" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2021/02/18/Docker中安装WordPress/" title="Docker中安装WordPress">
  <strong>上一篇：</strong><br/>
  <span>
  Docker中安装WordPress</span>
</a>
</div>


<div class="next">
<a href="/2021/01/20/Windows Terminal 完美配置 PowerShell 7.1/"  title="Windows Terminal 完美配置 PowerShell 7.1">
 <strong>下一篇：</strong><br/> 
 <span>Windows Terminal 完美配置 PowerShell 7.1
</span>
</a>
</div>

</nav>

	



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%BF%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%9B%86%E3%80%81%E7%B1%BB%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%AD%97%E6%AE%B5%E7%AD%89-%E4%B8%80"><span class="toc-number">1.</span> <span class="toc-text">C#动态创建和动态使用程序集、类、方法、字段等(一)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">动态创建代码</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/C/" title="C#">C#<sup>18</sup></a></li>
		  
		
		  
			<li><a href="/categories/CI-CD/" title="CI/CD">CI/CD<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/JAVA/" title="JAVA">JAVA<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/WPF/" title="WPF">WPF<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/linux/" title="linux">linux<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/linx/" title="linx">linx<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/nodejs/" title="nodejs">nodejs<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/前端/" title="前端">前端<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/大数据/" title="大数据">大数据<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/工具/" title="工具">工具<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/装机/" title="装机">装机<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/软件/" title="软件">软件<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/软件开发过程/" title="软件开发过程">软件开发过程<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/C/" title="C#">C#<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/linux/" title="linux">linux<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/WPF/" title="WPF">WPF<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/工具/" title="工具">工具<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/docker/" title="docker">docker<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/通信/" title="通信">通信<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/dotnetcore/" title="dotnetcore">dotnetcore<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/docker-compose/" title="docker-compose">docker-compose<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/MVVM/" title="MVVM">MVVM<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/MVVM-light/" title="MVVM light">MVVM light<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/ci-cd/" title="ci/cd">ci/cd<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Docker/" title="Docker">Docker<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/CI-CD/" title="CI/CD">CI/CD<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/reactor/" title="reactor">reactor<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/chart/" title="chart">chart<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/代理/" title="代理">代理<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/nginx/" title="nginx">nginx<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/生产者消费者/" title="生产者消费者">生产者消费者<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/消息通信/" title="消息通信">消息通信<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/HEXO/" title="HEXO">HEXO<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Knight Ark. <br/>
			This is my blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2021 
		
		<a href="/about" target="_blank" title="knightark">knightark</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>











<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
